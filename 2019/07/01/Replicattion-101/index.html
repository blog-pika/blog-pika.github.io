<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">

  <!-- PACE Progress Bar START -->
  
    <script src="https://raw.githubusercontent.com/HubSpot/pace/v1.0.2/pace.min.js"></script>
    <link rel="stylesheet" href="https://github.com/HubSpot/pace/raw/master/themes/orange/pace-theme-flash.css">
  
  

  <!-- PACE Progress Bar START -->

  
  <title>replication 101 | The Code and Sixpence</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Distributed SystemReplication">
  
  
  
  
  <meta name="description" content="AbstractThis blog is my reading notes for Designing Data-Intensive Applications, Chapter 05: Replication. Replication means keeping a copy of the same data on multiple machines that are connected via">
<meta name="keywords" content="Distributed System,Replication">
<meta property="og:type" content="article">
<meta property="og:title" content="Replication 101">
<meta property="og:url" content="https://blog-pika.github.io/2019/07/01/Replicattion-101/index.html">
<meta property="og:site_name" content="The Code and Sixpence">
<meta property="og:description" content="AbstractThis blog is my reading notes for Designing Data-Intensive Applications, Chapter 05: Replication. Replication means keeping a copy of the same data on multiple machines that are connected via">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://blog-pika.github.io/images/DDIA/Ch5-Single_Leader-Application.png">
<meta property="og:image" content="https://blog-pika.github.io/images/DDIA/Ch5-Multi-leader-replication.png">
<meta property="og:updated_time" content="2019-08-05T02:04:54.808Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Replication 101">
<meta name="twitter:description" content="AbstractThis blog is my reading notes for Designing Data-Intensive Applications, Chapter 05: Replication. Replication means keeping a copy of the same data on multiple machines that are connected via">
<meta name="twitter:image" content="https://blog-pika.github.io/images/DDIA/Ch5-Single_Leader-Application.png">
  
    <link rel="alternate" href="/atom.xml" title="The Code and Sixpence" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/hiero.css">
  <link rel="stylesheet" href="/css/glyphs.css">
  

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/my.css">
  <!-- Google Adsense -->
  
</head>
</html>
<script>
var themeMenus = {};

  themeMenus["/"] = "Home"; 

  themeMenus["/archives"] = "Archives"; 

  themeMenus["/categories"] = "Categories"; 

  themeMenus["/tags"] = "Tags"; 

  themeMenus["/about"] = "About"; 

</script>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="The Code and Sixpence" rel="home"> The Code and Sixpence </a>
            
          </h1>

          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>


  <div id="originBgDiv" style="background: #fff; width: 100%;">

      <div style="max-height:600px; overflow: hidden;  display: flex; display: -webkit-flex; align-items: center;">
        <img id="originBg" width="100%" alt="" src="">
      </div>

  </div>

  <script>
  function setAboutIMG(){
      var imgUrls = "css/images/pose.jpg,https://source.unsplash.com/collection/954550/1920x1080".split(",");
      var random = Math.floor((Math.random() * imgUrls.length ));
      if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
        document.getElementById("originBg").src=imgUrls[random];
      } else {
        document.getElementById("originBg").src='/' + imgUrls[random];
      }
  }
  bgDiv=document.getElementById("originBgDiv");
  if(location.pathname.match('about')){
    setAboutIMG();
    bgDiv.style.display='block';
  }else{
    bgDiv.style.display='none';
  }
  </script>



  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Replicattion-101" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Replication 101
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2019/07/01/Replicattion-101/" class="article-date">
	  <time datetime="2019-07-01T07:00:00.000Z" itemprop="datePublished">July 1, 2019</time>
	</a>

      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This blog is my reading notes for <em>Designing Data-Intensive Applications</em>, Chapter 05: Replication.</p>
<p><code>Replication</code> means keeping a copy of the <strong>same data</strong> on multiple machines that are connected via a network. It has following benefits:</p>
<ul>
<li><strong>High availability</strong>: Keeping the system running, even when one/several machines goes down</li>
<li><strong>Latency</strong>: Placing data geographically close to users, so that users can interact with it faster</li>
<li><strong>Scalability</strong>: Being able to handle a higher volume of <strong>reads</strong> than a single machine could handle, by performing reads on replicas</li>
</ul>
<a id="more"></a>

<p>However, keeping data consistent between replicas are not as simple as it looks. We need to consider the following issues: node failures; unreliable networks; and tradeoffs around replica consistency, durability, availability, and latency. Let’s look at them one by one:</p>
<ul>
<li>should we use synchronous or asynchronous?</li>
<li>which granularity of Replication Logs should we use?</li>
<li>which kind of replication architecture: Single-leader, multiple-leader, or leaderless?</li>
<li>should we provide consistency stronger than eventual consistency?</li>
<li>How to handle node failure and unreliable network?</li>
<li>How to handle concurrency write conflicts?</li>
</ul>
<h2 id="Synchronous-vs-Asynchronous"><a href="#Synchronous-vs-Asynchronous" class="headerlink" title="Synchronous vs Asynchronous"></a>Synchronous vs Asynchronous</h2><ul>
<li><code>synchronous</code>: the leader waits until follower has confirmed that it received the write before reporting success to the user, and before making the write visible to other clients.</li>
<li><code>asynchronous</code>: the leader sends the message, but doesn’t wait for a response from the follower.</li>
<li><code>semi-synchronous</code>: one of the followers is synchronous, and the others are asynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous followers is made synchronous. In practice, if you enable synchronous replication on a database, it usually means semi-synchronous.</li>
</ul>
<p><code>Synchronous</code> is impractical because the leader must block all writes and wait until the synchronous replica is available again. <strong>Often, leader-based replication is configured to be completely asynchronous</strong>. In this case, if the leader fails and is not recoverable, any writes that have not yet been replicated to followers are lost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the client. However, a fully asynchronous configuration has the advantage that the leader can continue processing writes, even if all of its followers have fallen behind.</p>
<h2 id="Granularity-of-Replication-Logs"><a href="#Granularity-of-Replication-Logs" class="headerlink" title="Granularity of Replication Logs"></a>Granularity of Replication Logs</h2><ul>
<li><p><code>Statement-based</code> replication: Deprecated. In the simplest case, the leader logs every write request (statement) that it executes and sends that statement log to its followers. For a relational database, this means that every INSERT, UPDATE, or DELETE statement is forwarded to followers, and each follower parses and executes that SQL statement as if it had been received from a client. Statements may be nondeterministic or have side effects, which causes replications diverge.</p>
</li>
<li><p><code>Write-ahead log</code> (WAL) shipping: the log is an append-only sequence of bytes containing all writes to the database. We can use the exact same log to build a replica on another node. The disadvantage is that it makes replication closely coupled to the storage engine. A newer software version usually had format compatibility issue, which requires downtime for upgrading.</p>
</li>
<li><p><code>Logical (row-based)</code> log replication: A logical log for a relational database is usually a sequence of records describing writes to database tables at the granularity of a row.</p>
</li>
</ul>
<h2 id="Replication-architectures"><a href="#Replication-architectures" class="headerlink" title="Replication architectures"></a>Replication architectures</h2><p>There are three main approaches to replication and each approach has advantages and disadvantages. Single-leader replication is popular because it is fairly easy to understand and there is no conflict resolution to worry about. Multi-leader and leaderless replication can be more robust in the presence of faulty nodes, network interruptions, and latency spikes—at the cost of being harder to reason about and providing only very weak consistency guarantees.</p>
<h3 id="Single-leader-replication"><a href="#Single-leader-replication" class="headerlink" title="Single-leader replication"></a>Single-leader replication</h3><ol>
<li>One of the replicas is designated the leader. Write requests of clients can only go to leader, which first writes the new data to its local storage.</li>
<li>The other replicas are known as followers . Whenever the leader writes new data to its local storage, it also sends the data change to all of its followers. Each follower takes the log from the leader and updates its local copy of the database accordingly.</li>
<li>When a client wants to read from the database, it can query either the leader or any of the followers. However, writes are only accepted on the leader.</li>
</ol>
<p><img src="/images/DDIA/Ch5-Single_Leader-Application.png" alt="Leader-based replication"></p>
<h3 id="Multi-leader-replication"><a href="#Multi-leader-replication" class="headerlink" title="Multi-leader replication"></a>Multi-leader replication</h3><p>Clients send each write to one of several leader nodes, any of which can accept writes. The leaders send streams of data change events to each other and to any follower nodes.</p>
<p><img src="/images/DDIA/Ch5-Multi-leader-replication.png" alt="Multi-leader replication across multiple data centers"></p>
<p>Multi-leader replication has advantage on performance, tolerance of datacenter outages, tolerance of network problems.<br>However, it rarely makes sense to use a multi-leader setup within a single datacenter, because the benefits rarely outweigh the added complexity: the same data may be concurrently modified in two different datacenters, and those write conflicts must be resolved.</p>
<p>Here are some common use cases for multi-leader replication:</p>
<ul>
<li>Multi-datacenter operation: Within each datacenter, regular leader-follower replication is used; between datacenters, each datacenter’s leader replicates its changes to the leaders in other datacenters.</li>
<li>Clients with offline operation: you have an application that needs to continue to work with multiple devices while they are disconnected from the internet.In this case, every device has a local database that acts as a leader (it accepts write requests), and there is an asynchronous multi-leader replication process (sync) between the replicas on all of your devices.</li>
<li>Collaborative editing: When one user edits a document, the changes are instantly applied to their local replica (the state of the document ) and asynchronously replicated to the server and any other users who are editing the same document.</li>
</ul>
<h3 id="Leaderless-replication"><a href="#Leaderless-replication" class="headerlink" title="Leaderless replication"></a>Leaderless replication</h3><p>Also called Dynamo-style: allow any replica to directly accept writes from clients. In some leaderless implementations, the client directly sends its writes to several replicas, while in others, a coordinator node does this on behalf of the client. However, unlike a leader database, that coordinator <strong>does not enforce a particular ordering of writes</strong>. Version numbers are used to determine which value is newer.</p>
<p><code>quorum reads and writes</code> tries to solve the issue of reading stale data: if there are n replicas, every write must be confirmed by w nodes(synchronized) to be considered successful, and we must query at least r nodes for each read. As long as there is an <strong>overlap</strong>, that is, w + r &gt; n, we expect to get an up-to-date value when reading. With a smaller w and r you are more likely to read stale values, but this configuration allows lower latency and higher availability.</p>
<p>However, even with w + r &gt; n, there are likely to be edge cases where stale values are returned, e.g., sloppy quorum, two writes occur concurrently, a write happens concurrently. Thus, <strong>Dynamo-style databases are generally optimized for use cases that can tolerate eventual consistency</strong>.</p>
<p>How to ensure that eventually all the data is copied to every replica? There are two ways:</p>
<ul>
<li><p><strong>Read repair</strong>: When a client makes a read from several nodes in parallel, it can detect any stale responses. The client then writes the newer value back to the replica that has stale data.<br>This approach works well for values that are frequently read. However, values that are rarely read may be missing from some replicas and thus have reduced durability.</p>
</li>
<li><p><strong>Anti-entropy process</strong>: a background process that constantly looks for differences in the data between replicas and copies any missing data from one replica to another. Unlike the replication log in leader-based replication, this anti-entropy process does not copy writes in any particular order, and there may be a significant delay before data is copied.</p>
</li>
</ul>
<h2 id="Node-Failures"><a href="#Node-Failures" class="headerlink" title="Node Failures"></a>Node Failures</h2><p>If a follower fails, we can use the <code>Catch-up</code> strategy. On its local disk, each follower keeps a log of the data changes it has received from the leader. If a follower crashes and is restarted, or if the network recovers from a temporary failure, it can connect to the leader and request all the data changes that occurred during the time when the follower was disconnected. When it has applied these changes, it has caught up to the leader and can continue receiving a stream of data changes as before.</p>
<p>If a leader fails, we can use the <code>Failover</code> strategy: one of the followers needs to be promoted to be the new leader, clients need to be reconfigured to send their writes to the new leader, and the other followers need to start consuming data changes from the new leader.</p>
<p>An automatic failover process usually consists of the following steps:</p>
<ol>
<li><p>Determining that the leader has failed. There is no foolproof way of detecting if a node is crashed or disconnected from the network, so most systems simply use a <strong>timeout</strong>: nodes frequently bounce heartbeat message back and forth between each other, and if a node doesn’t respond for some period of time, it is assumed to be dead.</p>
</li>
<li><p>Choosing a new leader. This could be done through an election process, or a new leader could be appointed by a previously elected controller node. The best candidate for leadership is usually the replica with the most up-to-date data changes from the old leader.</p>
</li>
<li><p>Reconfiguring the system to use the new leader. Clients now need to send their write requests to the new leader. The system needs to ensure that the old leader becomes a follower and recognizes the new leader, if the old leader comes back.</p>
</li>
</ol>
<h2 id="Challenges-with-Replication-Lag"><a href="#Challenges-with-Replication-Lag" class="headerlink" title="Challenges with Replication Lag"></a>Challenges with Replication Lag</h2><p>In an asynchronous architecture, client may see outdated information if the replica has fallen behind. If you stop writing to the database and wait a while, replicas will eventually catch up and become consistent with each other, which is known as <code>eventual consistency</code>.</p>
<p>When working with an eventually consistent system, it is worth thinking about how the application behaves if the replication lag increases to several minutes or even hours. If the answer is “no problem,” that’s great. However, if the result is a bad experience for users, it’s important to design the system to provide a stronger guarantee.</p>
<h3 id="Reading-Your-Own-Writes"><a href="#Reading-Your-Own-Writes" class="headerlink" title="Reading Your Own Writes"></a>Reading Your Own Writes</h3><p>When new data is submitted, it must be sent to the leader, but when the user views the data, it can be read from a follower. the new data may not yet have reached the replica. To the user, it looks as though the data they submitted was lost</p>
<p><code>read-after-write consistency</code>: This is a guarantee that if the user reloads the page, they will always see any updates they submitted themselves. It makes no promises about other users: other users’ updates may not be visible until some later time.</p>
<p>Implementations in leader-based architecture:</p>
<ul>
<li>If only a few things in the application are potentially editable by the user, when reading something that the user may have modified, read it from the leader; otherwise, read it from a follower</li>
<li>Use criteria to decide whether to read from the leader, i.e, for one minute after the last update, make all reads from the leader</li>
<li>The client can remember the timestamp of its most recent write. If a replica is not sufficiently up to date, query another replica or wait until the replica has caught up.</li>
</ul>
<h3 id="Monotonic-Reads"><a href="#Monotonic-Reads" class="headerlink" title="Monotonic Reads"></a>Monotonic Reads</h3><p>When reading from asynchronous followers is that it’s possible for a user to see things moving backward in time because of reading an out-of-date replica.</p>
<p><code>Monotonic reads</code>: if one user makes several reads in sequence, they will not read older data after having previously read newer data.</p>
<p>Implementation: each user always makes their reads from the same replica, i.e., the replica can be chosen based on a hash of the user ID.</p>
<h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p><code>consistent prefix reads</code>: if a sequence of writes happens in a certain order, then anyone reading those writes will see them appear in the same order.</p>
<p>One implementation is to make sure that any writes that are causally related to each other are written to the same partition.</p>
<h2 id="Concurrency-Write-Conflicts"><a href="#Concurrency-Write-Conflicts" class="headerlink" title="Concurrency Write Conflicts"></a>Concurrency Write Conflicts</h2><p>Concurrency Write issues are inherent in multi-leader and leaderless replication approaches: because they allow multiple writes to happen concurrently, conflicts may occur.</p>
<h3 id="Conflict-avoidance"><a href="#Conflict-avoidance" class="headerlink" title="Conflict avoidance"></a>Conflict avoidance</h3><p>If the application can ensure that all writes for a particular record go through the same leader, then conflicts cannot occur, i.e, route user write requests to the same leader based on the hash of its user id.</p>
<h3 id="Converging-toward-a-consistent-state"><a href="#Converging-toward-a-consistent-state" class="headerlink" title="Converging toward a consistent state"></a>Converging toward a consistent state</h3><p>Approaches that are dangerously prone to data loss:</p>
<ul>
<li>Give each <strong>write</strong> a unique ID (e.g., a timestamp, a long random number, a UUID, or a hash of the key and value), pick the write with the highest ID as the winner, and throw away the other writes. If a timestamp is used, this technique is known as <code>last write wins (LWW)</code></li>
<li>Give each replica a unique ID, and let writes that originated at a higher numbered replica always take precedence over writes that originated at a lower numbered replica.</li>
</ul>
<p>There are some situations, such as caching, in which lost writes are perhaps acceptable. If losing data is not acceptable, LWW is a poor choice for conflict resolution. The only safe way of using a database with LWW is to ensure that a key is only written once and thereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example, a recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a unique key</p>
<p>Other approaches are:</p>
<ul>
<li>merge the values together, e.g., order them alphabetically and then concatenate them</li>
<li>Record the conflict in an explicit data structure that preserves all information, and write application code that resolves the conflict at some later time (perhaps by prompting the user).</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p>[1] <em>Designing Data-Intensive Applications</em>, Chapter 05: Replication</p>
</blockquote>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-System/">Distributed System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Replication/">Replication</a></li></ul>

      
            
      
        
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'disqus_t7ZVi0Vi0o';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>


      
    </footer>
  </div>
  
    
  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article" style="overflow-y: scroll; max-width: 28%;">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract"><span class="nav-number">1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronous-vs-Asynchronous"><span class="nav-number">2.</span> <span class="nav-text">Synchronous vs Asynchronous</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Granularity-of-Replication-Logs"><span class="nav-number">3.</span> <span class="nav-text">Granularity of Replication Logs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Replication-architectures"><span class="nav-number">4.</span> <span class="nav-text">Replication architectures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-leader-replication"><span class="nav-number">4.1.</span> <span class="nav-text">Single-leader replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-leader-replication"><span class="nav-number">4.2.</span> <span class="nav-text">Multi-leader replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leaderless-replication"><span class="nav-number">4.3.</span> <span class="nav-text">Leaderless replication</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-Failures"><span class="nav-number">5.</span> <span class="nav-text">Node Failures</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Challenges-with-Replication-Lag"><span class="nav-number">6.</span> <span class="nav-text">Challenges with Replication Lag</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reading-Your-Own-Writes"><span class="nav-number">6.1.</span> <span class="nav-text">Reading Your Own Writes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monotonic-Reads"><span class="nav-number">6.2.</span> <span class="nav-text">Monotonic Reads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consistent-Prefix-Reads"><span class="nav-number">6.3.</span> <span class="nav-text">Consistent Prefix Reads</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Concurrency-Write-Conflicts"><span class="nav-number">7.</span> <span class="nav-text">Concurrency Write Conflicts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Conflict-avoidance"><span class="nav-number">7.1.</span> <span class="nav-text">Conflict avoidance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Converging-toward-a-consistent-state"><span class="nav-number">7.2.</span> <span class="nav-text">Converging toward a consistent state</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">8.</span> <span class="nav-text">Reference</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 The Code and Sixpence All Rights Reserved.
          
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

<!-- Custome JS -->
<script src="/js/my.js"></script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.js"></script>


<script src="/js/scripts.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'true', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->







	<script async src="https://dnqof95d40fo6.cloudfront.net/atw7f8.js">
	</script>





<!-- Tencent Analytics -->
	<script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId={{ theme.tencent_analytics }}";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
<!-- End Tencent Analytics -->


  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
