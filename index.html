<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>The Code and Sixpence</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="The Code and Sixpence">
<meta property="og:url" content="https://blog-pika.github.io/index.html">
<meta property="og:site_name" content="The Code and Sixpence">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Code and Sixpence">
  
    <link rel="alternate" href="/atom.xml" title="The Code and Sixpence" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">The Code and Sixpence</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog-pika.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Replicattion-101" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/Replicattion-101/" class="article-date">
  <time datetime="2019-07-01T07:00:00.000Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/Replicattion-101/">Replication 101</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This blog is my reading notes for <em>Designing Data-Intensive Applications</em>, Chapter 05: Replication.</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>Replication</code> means keeping a copy of the <strong>same data</strong> on multiple machines that are connected via a network. It has following benefits:</p>
<ul>
<li><strong>High availability</strong>: Keeping the system running, even when one/several machines goes down</li>
<li><strong>Latency</strong>: Placing data geographically close to users, so that users can interact with it faster</li>
<li><strong>Scalability</strong>: Being able to handle a higher volume of <strong>reads</strong> than a single machine could handle, by performing reads on replicas</li>
</ul>
<p>However, keeping data consistent between replicas are not as simple as it looks. We need to consider the following issues: node failures; unreliable networks; and tradeoffs around replica consistency, durability, availability, and latency. Let’s look at them one by one:</p>
<ul>
<li>should we use synchronous or asynchronous?</li>
<li>which granularity of Replication Logs should we use?</li>
<li>which kind of replication architecture: Single-leader, multiple-leader, or leaderless?</li>
<li>should we provide consistency stronger than eventual consistency?</li>
<li>How to handle node failure and unreliable network?</li>
<li>How to handle concurrency write conflicts?</li>
</ul>
<h2 id="Synchronous-vs-Asynchronous"><a href="#Synchronous-vs-Asynchronous" class="headerlink" title="Synchronous vs Asynchronous"></a>Synchronous vs Asynchronous</h2><ul>
<li><code>synchronous</code>: the leader waits until follower has confirmed that it received the write before reporting success to the user, and before making the write visible to other clients.</li>
<li><code>asynchronous</code>: the leader sends the message, but doesn’t wait for a response from the follower.</li>
<li><code>semi-synchronous</code>: one of the followers is synchronous, and the others are asynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous followers is made synchronous. In practice, if you enable synchronous replication on a database, it usually means semi-synchronous.</li>
</ul>
<p><code>Synchronous</code> is impractical because the leader must block all writes and wait until the synchronous replica is available again. <strong>Often, leader-based replication is configured to be completely asynchronous</strong>. In this case, if the leader fails and is not recoverable, any writes that have not yet been replicated to followers are lost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the client. However, a fully asynchronous configuration has the advantage that the leader can continue processing writes, even if all of its followers have fallen behind.</p>
<h2 id="Granularity-of-Replication-Logs"><a href="#Granularity-of-Replication-Logs" class="headerlink" title="Granularity of Replication Logs"></a>Granularity of Replication Logs</h2><ul>
<li><p><code>Statement-based</code> replication: Deprecated. In the simplest case, the leader logs every write request (statement) that it executes and sends that statement log to its followers. For a relational database, this means that every INSERT, UPDATE, or DELETE statement is forwarded to followers, and each follower parses and executes that SQL statement as if it had been received from a client. Statements may be nondeterministic or have side effects, which causes replications diverge.</p>
</li>
<li><p><code>Write-ahead log</code> (WAL) shipping: the log is an append-only sequence of bytes containing all writes to the database. We can use the exact same log to build a replica on another node. The disadvantage is that it makes replication closely coupled to the storage engine. A newer software version usually had format compatibility issue, which requires downtime for upgrading.</p>
</li>
<li><p><code>Logical (row-based)</code> log replication: A logical log for a relational database is usually a sequence of records describing writes to database tables at the granularity of a row.</p>
</li>
</ul>
<h2 id="Replication-architectures"><a href="#Replication-architectures" class="headerlink" title="Replication architectures"></a>Replication architectures</h2><p>There are three main approaches to replication and each approach has advantages and disadvantages. Single-leader replication is popular because it is fairly easy to understand and there is no conflict resolution to worry about. Multi-leader and leaderless replication can be more robust in the presence of faulty nodes, network interruptions, and latency spikes—at the cost of being harder to reason about and providing only very weak consistency guarantees.</p>
<h3 id="Single-leader-replication"><a href="#Single-leader-replication" class="headerlink" title="Single-leader replication"></a>Single-leader replication</h3><ol>
<li>One of the replicas is designated the leader. Write requests of clients can only go to leader, which first writes the new data to its local storage.</li>
<li>The other replicas are known as followers . Whenever the leader writes new data to its local storage, it also sends the data change to all of its followers. Each follower takes the log from the leader and updates its local copy of the database accordingly.</li>
<li>When a client wants to read from the database, it can query either the leader or any of the followers. However, writes are only accepted on the leader.</li>
</ol>
<p><img src="../images/DDIA/Ch5-Single_Leader-Application.png" alt="Leader-based replication"></p>
<h3 id="Multi-leader-replication"><a href="#Multi-leader-replication" class="headerlink" title="Multi-leader replication"></a>Multi-leader replication</h3><p>Clients send each write to one of several leader nodes, any of which can accept writes. The leaders send streams of data change events to each other and to any follower nodes.</p>
<p><img src="../images/DDIA/Ch5-Multi-leader-replication.png" alt="Multi-leader replication across multiple data centers"></p>
<p>Multi-leader replication has advantage on performance, tolerance of datacenter outages, tolerance of network problems.<br>However, it rarely makes sense to use a multi-leader setup within a single datacenter, because the benefits rarely outweigh the added complexity: the same data may be concurrently modified in two different datacenters, and those write conflicts must be resolved.</p>
<p>Here are some common use cases for multi-leader replication:</p>
<ul>
<li>Multi-datacenter operation: Within each datacenter, regular leader-follower replication is used; between datacenters, each datacenter’s leader replicates its changes to the leaders in other datacenters.</li>
<li>Clients with offline operation: you have an application that needs to continue to work with multiple devices while they are disconnected from the internet.In this case, every device has a local database that acts as a leader (it accepts write requests), and there is an asynchronous multi-leader replication process (sync) between the replicas on all of your devices.</li>
<li>Collaborative editing: When one user edits a document, the changes are instantly applied to their local replica (the state of the document ) and asynchronously replicated to the server and any other users who are editing the same document.</li>
</ul>
<h3 id="Leaderless-replication"><a href="#Leaderless-replication" class="headerlink" title="Leaderless replication"></a>Leaderless replication</h3><p>Also called Dynamo-style: allow any replica to directly accept writes from clients. In some leaderless implementations, the client directly sends its writes to several replicas, while in others, a coordinator node does this on behalf of the client. However, unlike a leader database, that coordinator <strong>does not enforce a particular ordering of writes</strong>. Version numbers are used to determine which value is newer.</p>
<p><code>quorum reads and writes</code> tries to solve the issue of reading stale data: if there are n replicas, every write must be confirmed by w nodes(synchronized) to be considered successful, and we must query at least r nodes for each read. As long as there is an <strong>overlap</strong>, that is, w + r &gt; n, we expect to get an up-to-date value when reading. With a smaller w and r you are more likely to read stale values, but this configuration allows lower latency and higher availability.</p>
<p>However, even with w + r &gt; n, there are likely to be edge cases where stale values are returned, e.g., sloppy quorum, two writes occur concurrently, a write happens concurrently. Thus, <strong>Dynamo-style databases are generally optimized for use cases that can tolerate eventual consistency</strong>.</p>
<p>How to ensure that eventually all the data is copied to every replica? There are two ways:</p>
<ul>
<li><p><strong>Read repair</strong>: When a client makes a read from several nodes in parallel, it can detect any stale responses. The client then writes the newer value back to the replica that has stale data.<br>This approach works well for values that are frequently read. However, values that are rarely read may be missing from some replicas and thus have reduced durability.</p>
</li>
<li><p><strong>Anti-entropy process</strong>: a background process that constantly looks for differences in the data between replicas and copies any missing data from one replica to another. Unlike the replication log in leader-based replication, this anti-entropy process does not copy writes in any particular order, and there may be a significant delay before data is copied.</p>
</li>
</ul>
<h2 id="Node-Failures"><a href="#Node-Failures" class="headerlink" title="Node Failures"></a>Node Failures</h2><p>If a follower fails, we can use the <code>Catch-up</code> strategy. On its local disk, each follower keeps a log of the data changes it has received from the leader. If a follower crashes and is restarted, or if the network recovers from a temporary failure, it can connect to the leader and request all the data changes that occurred during the time when the follower was disconnected. When it has applied these changes, it has caught up to the leader and can continue receiving a stream of data changes as before.</p>
<p>If a leader fails, we can use the <code>Failover</code> strategy: one of the followers needs to be promoted to be the new leader, clients need to be reconfigured to send their writes to the new leader, and the other followers need to start consuming data changes from the new leader.</p>
<p>An automatic failover process usually consists of the following steps:</p>
<ol>
<li><p>Determining that the leader has failed. There is no foolproof way of detecting if a node is crashed or disconnected from the network, so most systems simply use a <strong>timeout</strong>: nodes frequently bounce heartbeat message back and forth between each other, and if a node doesn’t respond for some period of time, it is assumed to be dead.</p>
</li>
<li><p>Choosing a new leader. This could be done through an election process, or a new leader could be appointed by a previously elected controller node. The best candidate for leadership is usually the replica with the most up-to-date data changes from the old leader.</p>
</li>
<li><p>Reconfiguring the system to use the new leader. Clients now need to send their write requests to the new leader. The system needs to ensure that the old leader becomes a follower and recognizes the new leader, if the old leader comes back.</p>
</li>
</ol>
<h2 id="Challenges-with-Replication-Lag"><a href="#Challenges-with-Replication-Lag" class="headerlink" title="Challenges with Replication Lag"></a>Challenges with Replication Lag</h2><p>In an asynchronous architecture, client may see outdated information if the replica has fallen behind. If you stop writing to the database and wait a while, replicas will eventually catch up and become consistent with each other, which is known as <code>eventual consistency</code>.</p>
<p>When working with an eventually consistent system, it is worth thinking about how the application behaves if the replication lag increases to several minutes or even hours. If the answer is “no problem,” that’s great. However, if the result is a bad experience for users, it’s important to design the system to provide a stronger guarantee.</p>
<h3 id="Reading-Your-Own-Writes"><a href="#Reading-Your-Own-Writes" class="headerlink" title="Reading Your Own Writes"></a>Reading Your Own Writes</h3><p>When new data is submitted, it must be sent to the leader, but when the user views the data, it can be read from a follower. the new data may not yet have reached the replica. To the user, it looks as though the data they submitted was lost</p>
<p><code>read-after-write consistency</code>: This is a guarantee that if the user reloads the page, they will always see any updates they submitted themselves. It makes no promises about other users: other users’ updates may not be visible until some later time.</p>
<p>Implementations in leader-based architecture:</p>
<ul>
<li>If only a few things in the application are potentially editable by the user, when reading something that the user may have modified, read it from the leader; otherwise, read it from a follower</li>
<li>Use criteria to decide whether to read from the leader, i.e, for one minute after the last update, make all reads from the leader</li>
<li>The client can remember the timestamp of its most recent write. If a replica is not sufficiently up to date, query another replica or wait until the replica has caught up.</li>
</ul>
<h3 id="Monotonic-Reads"><a href="#Monotonic-Reads" class="headerlink" title="Monotonic Reads"></a>Monotonic Reads</h3><p>When reading from asynchronous followers is that it’s possible for a user to see things moving backward in time because of reading an out-of-date replica.</p>
<p><code>Monotonic reads</code>: if one user makes several reads in sequence, they will not read older data after having previously read newer data.</p>
<p>Implementation: each user always makes their reads from the same replica, i.e., the replica can be chosen based on a hash of the user ID.</p>
<h3 id="Consistent-Prefix-Reads"><a href="#Consistent-Prefix-Reads" class="headerlink" title="Consistent Prefix Reads"></a>Consistent Prefix Reads</h3><p><code>consistent prefix reads</code>: if a sequence of writes happens in a certain order, then anyone reading those writes will see them appear in the same order.</p>
<p>One implementation is to make sure that any writes that are causally related to each other are written to the same partition.</p>
<h2 id="Concurrency-Write-Conflicts"><a href="#Concurrency-Write-Conflicts" class="headerlink" title="Concurrency Write Conflicts"></a>Concurrency Write Conflicts</h2><p>Concurrency Write issues are inherent in multi-leader and leaderless replication approaches: because they allow multiple writes to happen concurrently, conflicts may occur.</p>
<h3 id="Conflict-avoidance"><a href="#Conflict-avoidance" class="headerlink" title="Conflict avoidance"></a>Conflict avoidance</h3><p>If the application can ensure that all writes for a particular record go through the same leader, then conflicts cannot occur, i.e, route user write requests to the same leader based on the hash of its user id.</p>
<h3 id="Converging-toward-a-consistent-state"><a href="#Converging-toward-a-consistent-state" class="headerlink" title="Converging toward a consistent state"></a>Converging toward a consistent state</h3><p>Approaches that are dangerously prone to data loss:</p>
<ul>
<li>Give each <strong>write</strong> a unique ID (e.g., a timestamp, a long random number, a UUID, or a hash of the key and value), pick the write with the highest ID as the winner, and throw away the other writes. If a timestamp is used, this technique is known as <code>last write wins (LWW)</code></li>
<li>Give each replica a unique ID, and let writes that originated at a higher numbered replica always take precedence over writes that originated at a lower numbered replica.</li>
</ul>
<p>There are some situations, such as caching, in which lost writes are perhaps acceptable. If losing data is not acceptable, LWW is a poor choice for conflict resolution. The only safe way of using a database with LWW is to ensure that a key is only written once and thereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example, a recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a unique key</p>
<p>Other approaches are:</p>
<ul>
<li>merge the values together, e.g., order them alphabetically and then concatenate them</li>
<li>Record the conflict in an explicit data structure that preserves all information, and write application code that resolves the conflict at some later time (perhaps by prompting the user).</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p>[1] <em>Designing Data-Intensive Applications</em>, Chapter 05: Replication</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2019/07/01/Replicattion-101/" data-id="cjyxp3xdc001ajqm9mm2qcdde" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Distributed-System/">Distributed System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Replication/">Replication</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix09 - Summary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/Weenix/Weenix09 - Summary/" class="article-date">
  <time datetime="2018-04-20T07:00:02.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/Weenix/Weenix09 - Summary/">Weenix09 - Summary</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua, Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them. </p>
<p>The kernel assignment is divided into three parts. And in these blogs, I record some important ideas to understand the kernel, plus some mistakes we made.</p>
<h1 id="Catalogue"><a href="#Catalogue" class="headerlink" title="Catalogue"></a>Catalogue</h1><p>The first part of the assignment is to implement the completed life cycle of threads and processes with FIFO scheduling policy, scheduling algorithm, and mutex. You can refer to this blog:<br><a href="http://blog.taowang.cloud/2018/03/01/Weenix/Weenix01%20-%20Process-and-Thread/" target="_blank" rel="noopener">Weenix01 - Process and Thread</a></p>
<p>The second part of the assignment is to build up a Virtual File System layer to bridge between the OS kernel and various Actual File Systems. You can refer to these blogs:<br><a href="http://blog.taowang.cloud/2018/04/02/Weenix/Weenix02%20-%20Virtual-File-System-Overview/" target="_blank" rel="noopener">Weenix02 - Virtual File System Overview</a><br><a href="http://blog.taowang.cloud/2018/04/02/Weenix/Weenix03%20-%20Debug-Virtual-File-System/" target="_blank" rel="noopener">Weenix03 - Debug Virtual File System</a></p>
<p>The third part of the assignment is to construct Virtual Memory module to support user-level program, which supports features such as system call, demanding pages, copy-on-write, and fork. You can refer to these blogs:<br><a href="http://blog.taowang.cloud/2018/04/15/Weenix/Weenix04%20-%20Virtual%20Memeory%20Overview/" target="_blank" rel="noopener">Weenix04 - Virtual Memory Overview</a><br><a href="http://blog.taowang.cloud/2018/04/15/Weenix/Weenix05%20-%20Implementation%20of%20Virtual%20Memory/" target="_blank" rel="noopener">Weenix05 - Implementation of Virtual Memory</a><br><a href="http://blog.taowang.cloud/2018/04/15/Weenix/Weenix06%20-%20Debug%20anon_put()/" target="_blank" rel="noopener">Weenix06 - Debug anon_put()</a><br><a href="http://blog.taowang.cloud/2018/04/20/Weenix/Weenix07%20-%20Shadow%20Object/" target="_blank" rel="noopener">Weenix07 - Shadow Object</a><br><a href="http://blog.taowang.cloud/2018/04/20/Weenix/Weenix08%20-%20Fork/" target="_blank" rel="noopener">Weenix08 - Fork</a>  </p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>After finishing the Weenix Kernel, you will get a user-space shell which is able to run the command and execute the binary file. The screenshot of the shell is like the picture below:<br><img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix10-Summary/Demo.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/20/Weenix/Weenix09 - Summary/" data-id="cjyxp3xe9001vjqm9rswa6kjm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix08 - Fork" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/Weenix/Weenix08 - Fork/" class="article-date">
  <time datetime="2018-04-20T07:00:01.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/Weenix/Weenix08 - Fork/">Weenix08 - Fork</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>The faq of the fork system call is very detailed and the pseudo code is like that:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(struct regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Create a copy of the curproc, handles vmmap_t, shadow object, etc accordingly. */</span></span><br><span class="line">        <span class="keyword">proc_t</span> *child_proc = proc_clone_except_thread();</span><br><span class="line">       </span><br><span class="line">        uncache_pt_and_tlb();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Create a clone of the curthr, associate it with the child_proc */</span></span><br><span class="line">        <span class="keyword">kthread_t</span> *child_thr = create_child_thread(child_proc, regs);</span><br><span class="line">        sched_make_runnable(child_thr);</span><br><span class="line"></span><br><span class="line">        regs-&gt;r_eax = child_proc-&gt;p_pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> child_proc-&gt;p_pid;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="How-to-Distinguish-Return-Value"><a href="#How-to-Distinguish-Return-Value" class="headerlink" title="How to Distinguish Return Value?"></a>How to Distinguish Return Value?</h1><p>One challenging question is how to distinguish parent process and child process, then return different value accordingly? <strong>The solution is in the r_eax register, which stores the return value of a function.</strong> </p>
<p>If we set the r_eax registers of the child process and parent process accordingly, their return value will be different. Therefore, when we create the child thread, we should set regs-&gt;r_eax to 0; as for the parent process, we should set the regs-&gt;r_eax to child_proc-&gt;p_pid. </p>
<h1 id="Why-do-we-need-flush-TLB"><a href="#Why-do-we-need-flush-TLB" class="headerlink" title="Why do we need flush TLB?"></a>Why do we need flush TLB?</h1><p>In the picture below, if we do not unmap the user-space page table, then the page x1 is R/W. Since x1 is R/W and in the memory, process A, and B can lookup this page directly, that is, process A and B share this page. This is not what we expect for forking, instead, process A and B should each has a private copy of page B.  </p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix09%20-%20Fork/Fork-Unmap-User-space.png">

<p>That’s why we need to unmap the entire user-space page table when doing fork(). <strong>Pages will be set to R/O on the next page fault if reading.</strong></p>
<p>We met another problem when implementing uncache_pt_and_tlb(). At first, we do flushing in a for loop, which is incredibly slow. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(from USER_MEM_LOW; to USER_MEM_HIGH)&#123;</span><br><span class="line">    tlb_flush_range</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, if we use tlb_flush_all(), which is implemented by the hardware, it will be much faster.</p>
<h2 id="How-Vmarea-changes-when-forking"><a href="#How-Vmarea-changes-when-forking" class="headerlink" title="How Vmarea changes when forking?"></a>How Vmarea changes when forking?</h2><p>If the mmobj is shared, then the change is as follow:<br><img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix09%20-%20Fork/Fork(Shared).png"></p>
<p>If the mmobj is private, then the change is as follow:<br><img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix09%20-%20Fork/Fork(Private).png"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/20/Weenix/Weenix08 - Fork/" data-id="cjyxp3xe8001tjqm9maz2uedy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fork/">Fork</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix07 - Shadow Object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/Weenix/Weenix07 - Shadow Object/" class="article-date">
  <time datetime="2018-04-20T07:00:00.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/Weenix/Weenix07 - Shadow Object/">Weenix07 - Shadow Object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>To support both fork and copy-on-write, we should make use of shadow objects, without which supporting these two features will be a great mess. You can refer to the textbook for details about shadow objects.</p>
<p>The shape of all shadow objects of a process is like a reversed tree and <strong>the higher layer records the more up-to-date modifications</strong>. Some similar ideas can be found in functional programming. </p>
<p>For example, let’s see the picture below. Initially process A has pages x0, y0, y0(layer0). When process A modifies page x0, the shadow object records the new page x1(layer1). When process A forks, process A and child process will have new shadow objects(layer2). When Process A modifies page z and Process B modifies page y, the modifications will be recorded in layer 2. When process B forks, process B, and child process C will have new shadow objects(layer3).</p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix08%20-%20Shadow%20Object/Shadow-Object.png">

<p>Therefore, we can trace the latest pages and the original pages conveniently. For process A, the latest pages are in the upper layer, x1, y0, z2; and the original pages are in the bottom, x0, y0, z0.</p>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>We need to handle the logic for both copy-on-write and do-not-copy-on-not-write. There are 3 important and useful functions: pframe_get_resident() and pframe_get()/pframe_lookup(). </p>
<p>pframe_get_resident() merely does lookup operation; pframe_get() also does lookup operation, however, if the pframe is not in the memory, pframe_alloc() and pframe_fill() will be called and a new pframe will be created; pframe_lookup() is identical to pframe_get(), which calls the lookuppage operation of mmobj and eventualy calls pframe_get(). </p>
<p>Therefore, <strong>we can use pframe_get_resident() to implement do-not-copy-on-not-write logic and use pframe_get() to implement copy-on-write logic.</strong></p>
<h2 id="shadow-lookuppage"><a href="#shadow-lookuppage" class="headerlink" title="shadow_lookuppage()"></a>shadow_lookuppage()</h2><p>shadow_lookuppage() only handles the logic for do-not-copy-on-not-write magic. The logic is simple: start searching from mmobj o, the first pframe is the most up-to-date pframe that we need. </p>
<p><strong>The desired page may not be in memory now.</strong> In this case, we need to use pframe_lookup() to bring this pframe into memory(for files objects) or created a new pframe(for anonymous objects).</p>
<p> The psuedo code is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">shadow_lookuppage(<span class="keyword">mmobj_t</span> *o, <span class="keyword">uint32_t</span> pagenum, <span class="keyword">int</span> forwrite, <span class="keyword">pframe_t</span> **pf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (need to <span class="keyword">do</span> write)&#123;</span><br><span class="line">                <span class="keyword">return</span> pframe_get(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pframe_t</span> *p = <span class="literal">NULL</span>; </span><br><span class="line">        iterate every layer of shadow object&#123;</span><br><span class="line">            <span class="keyword">if</span>(pframe_get_resident(desired page))&#123;</span><br><span class="line">                p = desired page;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cannot find the desired page)&#123;</span><br><span class="line">            pframe_lookup(bottom_mmobj, desired page, &amp;p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *pf = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shadow-fillpage"><a href="#shadow-fillpage" class="headerlink" title="shadow_fillpage()"></a>shadow_fillpage()</h2><p>Recall that when a process is created or does fork() operation, it will get a new layer of shadow object, which contains no pframes. At that time, if we want to look up a page for write, shadow_fillpage() will be called.<br>The flow is like that:</p>
<blockquote>
<p> shadow_lookuppage(forwrite == 1)<br>-&gt; pframe_get() and cannot get the pframe<br>-&gt; pframe_fill()<br>-&gt; shadow_fillpage()</p>
</blockquote>
<p>The pseudo code is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">shadow_fillpage(<span class="keyword">mmobj_t</span> *o, <span class="keyword">pframe_t</span> *pf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">pframe_t</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        start iteration from o-&gt;mmo_shadowed &#123;</span><br><span class="line">             <span class="keyword">if</span>(pframe_get_resident(desired page))&#123;</span><br><span class="line">                p = desired page;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cannot find the desired page)&#123;</span><br><span class="line">            <span class="keyword">mmobj_t</span> *bottom = bottom mmobj;</span><br><span class="line">            pframe_lookup(bottom_mmobj, desired page, &amp;p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(pf-&gt;pf_addr, p-&gt;pf_addr, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The basic logic is that: find the most up-to-date pframe and use memcpy to copy it into the pf pframe. The comment is more specific: “fill the page frame starting at address pf-&gt;pf_addr with the contents of the page identified by pf-&gt;pf_obj and pf-&gt;pf_pagenum.”</p>
<p><strong>One thing should be noted is that the iteration starts from o-&gt;mmo_shadowed.</strong> Because we need to copy the most up-to-date pframe into the latest shadow object and the most up-to-date pframe stays in the layer starting from o-&gt;mmo_shadowed.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/20/Weenix/Weenix07 - Shadow Object/" data-id="cjyxp3xe6001pjqm96my89o07" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix06 - Debug anon_put()" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/Weenix/Weenix06 - Debug anon_put()/" class="article-date">
  <time datetime="2018-04-15T07:00:02.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Weenix/Weenix06 - Debug anon_put()/">Weenix06 - Debug anon_put()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua, Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>One of the functions we need to write in the Weenix assignment is anon_put(). You can read the following comments to understand this function.</p>
<p>The pseudocode of the wrong version of <strong>anon_put()</strong> is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decrement the reference count on the object. If, however, the</span></span><br><span class="line"><span class="comment"> * reference count on the object reaches the number of resident</span></span><br><span class="line"><span class="comment"> * pages of the object, we can conclude that the object is no</span></span><br><span class="line"><span class="comment"> * longer in use and, since it is an anonymous object, it will</span></span><br><span class="line"><span class="comment"> * never be used again. You should unpin and uncache all of the</span></span><br><span class="line"><span class="comment"> * object's pages and then free the object itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">anon_put(<span class="keyword">mmobj_t</span> *o)</span><br><span class="line">&#123;   </span><br><span class="line">        o-&gt;mmo_refcount--;</span><br><span class="line">        <span class="keyword">if</span>(o-&gt;mmo_refcount == o-&gt;mmo_nrespages + <span class="number">1</span>)&#123;</span><br><span class="line">                Iterate_pframe_list&#123;</span><br><span class="line">                    pframe_unpin(pf);</span><br><span class="line">                    pframe_free(pf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                slab_obj_free(anon_allocator, o);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Problem-And-Analysis"><a href="#Problem-And-Analysis" class="headerlink" title="Problem And Analysis"></a>Problem And Analysis</h1><p>In the implemetion below, we got kernel panic:</p>
<blockquote>
<p>panic in mm/slab.c:342 slab_obj_free(): assertio failed: !obj_bufctl(allocator, obj)-&gt;sb_free &amp;&amp; “INVALID FREE!”</p>
</blockquote>
<p>By tracking the code execution with GDB, we can see that <strong>slab_obj_free(anon_allocator, o);</strong> is executed twice. And executing free more than once for the same mmobj will cause the kernel panic.</p>
<p>The reason is that the design of pframe_free() is not as we expect. Inside pframe_free(), it calls anon_put() recursively. The source code is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deallocates a pframe (reclaims the page frame for use by something else).</span></span><br><span class="line"><span class="comment"> * The page should not be pinned, free, or busy. Note that if the page is dirty</span></span><br><span class="line"><span class="comment"> * it will not be cleaned. This removes the page's reference to its mmobj.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine may block in the mmobj put operation.</span></span><br><span class="line"><span class="comment"> * @param pf the page to free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">pframe_free(<span class="keyword">pframe_t</span> *pf)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// Some codes which are not important....</span></span><br><span class="line">        o-&gt;mmo_nrespages--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now that pf has effectively been freed, dereference the corresponding</span></span><br><span class="line"><span class="comment">         * object. We don't do this earlier as we are modifying the object's counts</span></span><br><span class="line"><span class="comment">         * and also because this op can block */</span></span><br><span class="line">        o-&gt;mmo_ops-&gt;put(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The execution flow of the wrong version of anon_put() function is as follow. We can see that slab_obj_free(anon_allocator, o); is executed twice.<br><img src="https://bytebucket.org/LarryTaoWang/pictureofblog/raw/7bb447cdfe96078af3a860edf3c3d434e247c08b/Weenix/Weenix%20-%20Debug%20Hello%20Work%20-%20anon_put%28%29/Wrong%20anon_put%28%29%20work%20flow.png">  </p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>If we change our code a little bit, then everything works well.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">anon_put(<span class="keyword">mmobj_t</span> *o)</span><br><span class="line">&#123;   </span><br><span class="line">        <span class="keyword">if</span>(o-&gt;mmo_refcount == o-&gt;mmo_nrespages + <span class="number">1</span>)&#123;</span><br><span class="line">                Iterate_pframe_list&#123;</span><br><span class="line">                    pframe_unpin(pf);</span><br><span class="line">                    pframe_free(pf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                slab_obj_free(anon_allocator, o);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;mmo_refcount--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The execution flow of the correct version of anon_put() function is as follow.<br><img src="https://bytebucket.org/LarryTaoWang/pictureofblog/raw/7bb447cdfe96078af3a860edf3c3d434e247c08b/Weenix/Weenix%20-%20Debug%20Hello%20Work%20-%20anon_put%28%29/Correct%20anon_put%28%29%20work%20flow.png">  </p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/15/Weenix/Weenix06 - Debug anon_put()/" data-id="cjyxp3xe5001ojqm9zxxx6uzz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix05 - Implementation of Virtual Memory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/Weenix/Weenix05 - Implementation of Virtual Memory/" class="article-date">
  <time datetime="2018-04-15T07:00:01.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Weenix/Weenix05 - Implementation of Virtual Memory/">Weenix05 - Implementation of Virtual Memory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This blog illustrates some pitfalls and my understanding of some functions for implementing virtual memory for Weenix(exclude fork and copy-on-write). The overview of some basic components of virtual memory is presented by this picture.</p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix%20-%20Virtual%20Memory%20Overview/Overview%20of%20Virtual%20memory%20data%20strcure.png">


<h1 id="mmap-c"><a href="#mmap-c" class="headerlink" title="mmap.c"></a>mmap.c</h1><p>This file contains most of the function we need to manage vmmap, the linked list of vmareas. One pitfall is that the vma_off of vmarea is exclusive, so we need to be careful about whether we need to include the boundary vma_off in if statements or loop statements.</p>
<h2 id="vmmap-map"><a href="#vmmap-map" class="headerlink" title="vmmap_map()"></a>vmmap_map()</h2><p>The comment says “If file is NULL an anon mmobj will be used to create a mapping 0’s.  If file is non-null that vnode’s file will be mapped in for the given range.” We are confused about what “create a mapping 0’s” means. Later we found out that when you create an anon object, you need to fill the page with all 0, otherwise you cannot pass the memory check. The logic for filling the page can be implemented in anoc.c.</p>
<h2 id="vmmap-is-range-empty"><a href="#vmmap-is-range-empty" class="headerlink" title="vmmap_is_range_empty()"></a>vmmap_is_range_empty()</h2><p>The comment says: “Returns 1 if the given address space has no mappings for the given range, 0 otherwise”. We are confused about the definition at first. Later we found that it means that if the address space [startvfn, startvfn + npages) is not interleaving with any existed vmarea, return 1; otherwise return 0.</p>
<h2 id="vmmap-read-and-vmmap-write"><a href="#vmmap-read-and-vmmap-write" class="headerlink" title="vmmap_read() and vmmap_write()"></a>vmmap_read() and vmmap_write()</h2><p>Special thanks to my friend Weiji Lin for helping me understand this function.</p>
<p>These two functions are used by copy_to_user and copy_from_user, whose comments say “copy_to_user and copy_from_user are used to <strong>copy to and from the user space</strong> of the current process. They first check that the range of addresses has valid mappings, then call vmmap_read/write.”</p>
<p>If we want to copy memory from one kernel-address to another kernel-address, we can simply call <strong>memcpy (destination, source, num)</strong>, because memory is continuous in kernel-space. However, if we want to copy data between user-address and kernel-address, things will become a little more complicated. The reason is that <strong>a count with starting address of buf may span multiple vmareas</strong>. One solution is <strong>not to copy data across page boundaries</strong>, which assures that the copy will not across different vmareas.</p>
<p>The implementation of memcpy() in user-space locates in “kernel1/user/lib/libc/string.c”.</p>
<h1 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h1><p>The logic of most of the sys_* functions is quite similar and easy to understand. According to the comment, you need to “page_alloc() a temporary buffer” and then “call do_read(), and copy_to_user() the read bytes”. Since page_alloc() only allocates one page, you have to do_read() and copy_to_user page by page.</p>
<p>“copy_to_user” we used to copy the primitives, the “user_strdup” function is used to copy the string.</p>
<h1 id="pagefault-c"><a href="#pagefault-c" class="headerlink" title="pagefault.c"></a>pagefault.c</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>When a pagefault happens, _pt_fault_handler() calls handle_pagefault() after doing some error checkings.<br>The outline of pt_fault_handler is as follow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use vmmap_lookup() to find the corresponding vmarea;</span></span><br><span class="line"><span class="comment">// Check whether the vmarea has the corresponding permission;</span></span><br><span class="line"><span class="comment">// Use pframe_lookup() to get the missing page frame;</span></span><br><span class="line"><span class="comment">// Call pt_map to have the new mapping placed into the appropriate page table;</span></span><br></pre></td></tr></table></figure>

<h2 id="Check-permission"><a href="#Check-permission" class="headerlink" title="Check permission"></a>Check permission</h2><p>The comment says “Make sure to check the permissions on the <strong>area</strong> to see if the process has permission to do [cause]” Be careful that it is the permission of <strong>vmarea</strong> that we need to check, rather than the permission of pframe.</p>
<p>If the vmarea does not have the permission, we need to terminate the process, e.g., this vmarea is a text segment and we want to write to it. If we have the permission to write the vmarea, but the pframe is R/O, then it is time to do the copy-on-write. </p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix06%20-%20Implementation%20of%20Virtual%20Memory/Pagefault.png">


<h2 id="Copy-on-write"><a href="#Copy-on-write" class="headerlink" title="Copy-on-write"></a>Copy-on-write</h2><p>The comment says: “Now it is time to find the correct page (don’t forget about shadow objects, especially copy-on-write magic!). Make sure that if the user writes to the page it will be handled correctly.”</p>
<p>Personally, this comment is a little misleading. We should not bother handling the copy-on-write logic at all, which should be implemented in shadow.c instead. The handle_pagefault() merely need to call pframe_lookup(). And thanks to the magic of polymorphism, the mmobj will do copy-on-write(or not) accordingly. </p>
<h2 id="Kernel-Memory-and-User-Memory-Mapping"><a href="#Kernel-Memory-and-User-Memory-Mapping" class="headerlink" title="Kernel Memory and User Memory Mapping"></a>Kernel Memory and User Memory Mapping</h2><p>A pframe has 2 virtual address: one for the kernel space and one for the user-space, which are necessary for page fault. If we have a page fault at a user-space address, then the virtual address of this user-space is invalid, and the kernel cannot make use of it to write anything to the physical page. Instead, the kernel uses the kernel-space virtual address.</p>
<p>pf-&gt;pf_addr is a kernel-space virtual address; the page fault address (vaddr) is a user-space virtual address. In the implementation of pagefault(), finally we will call pt_map(), then these 2 addresses map to the same physical page.</p>
<h1 id="How-hello-world-is-executed"><a href="#How-hello-world-is-executed" class="headerlink" title="How hello world is executed"></a>How hello world is executed</h1><img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix06%20-%20Implementation%20of%20Virtual%20Memory/How%20hello%20world%20execute.png">


<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/15/Weenix/Weenix05 - Implementation of Virtual Memory/" data-id="cjyxp3xdz001kjqm9kpoov6r0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix04 - Virtual Memeory Overview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/Weenix/Weenix04 - Virtual Memeory Overview/" class="article-date">
  <time datetime="2018-04-15T07:00:00.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Weenix/Weenix04 - Virtual Memeory Overview/">Weenix04 - Virtual Memory Overview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>In the previous kernel assignment, we developed threads and processes, Virtual File System, and now it is time to implement Virtual Memory, with which the kernel is able to support the user-space processes. Personally, virtual memory is hard to understand, implement and debug. So it is a good idea to read the textbook, the weenix documentation, and the FAQ thoroughly.</p>
<p>Below is an important picture of virtual memory. </p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix%20-%20Virtual%20Memory%20Overview/Address-space%20representation%20in%20the%20textbook.png ">  

<p>When the hello.c file is compiled into hello.exec file, the compiler will compile it different segments, which are loaded into the memory separately with their file object or anon object. Furthermore, memory is split into a fixed size of pages(in 32-bit machine 4KB per page), so a segment may have a lot of pages.</p>
<p>For example, after the text segment is compiled and loaded into the memory, it becomes the region “as_region 1000-7fff, rx, shared”. The starting page number is 1000, the end page number is 7fff, so the segment has (7fff - 1000 + 1) pages in theory.</p>
<p>We can use the virtual address to access the segment. For example, if we want to access address 0x1000000, then the corresponding page is (0x1000000 &lt;&lt; 12 = 0x1000). If this page is already in memory, we can get it immediately; otherwise, a page fault will occur and the file object will load it from disk into memory, then we can get it.</p>
<h1 id="Data-Structure-in-Weenix"><a href="#Data-Structure-in-Weenix" class="headerlink" title="Data Structure in Weenix"></a>Data Structure in Weenix</h1><p>Below is a similar picture of the picture above, but described in the data structure in the Weenix kernel. In the picture below, the “PCB” is implemented by the struct “proc_t”; the “address space” is implemented by the struct “vmmap_t”; the “as region” is implemented by the struct “vmarea_t”; the “file object / anon object” is implemented by the struct “mmobj_t”. Besides Weenix we have a data structure called “pframe”, which has the one-to-one mapping relationship with a physical page.</p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix%20-%20Virtual%20Memory%20Overview/Overview%20of%20Virtual%20memory%20data%20strcure.png">

<h2 id="Struct-vmmap-t-and-vmarea-t"><a href="#Struct-vmmap-t-and-vmarea-t" class="headerlink" title="Struct vmmap_t and vmarea_t"></a>Struct vmmap_t and vmarea_t</h2><p>Every process has its own address space and page table, so, in weenix, struc proc_t has a filed <strong>vmmap_t</strong>, which is the head of a linked list containing all the vmareas(as_regions) of this process. </p>
<p>The vma_start is inclusive but the vma_end is exclusive, so for the as_region 1000-7fff, vma_start = 1000 and vma_end = 8000. Remember that in Weenix the basic unit for memory allocation is a page of 4KB size. So, <strong>the mapping boundaries, vma_start, and vma_end are in terms of page numbers and not addresses</strong>! Weenix provides several handy macros to do this kind of conversion in “page.h” such as converting the address to page number.</p>
<blockquote>
<p>#define ADDR_TO_PN(x) (((uint32_t)(x)) &gt;&gt; PAGE_SHIFT)</p>
</blockquote>
<p>The field <strong>vma_olink</strong> is declared in the struct vmarea_t, but it is OK if you just ignore it. It seems this field is not used at all.</p>
<p>Every vmarea should have a file object/anon object, which is implemented as the struct “mmobj_t”. <strong>A vmarea uses a mmobj to “read pages”</strong>. Since the physical page has a one-to-one mapping relationship with the frame, we can also say that <strong>a vmarea use a mmobj to manage physical pages/ pframes.</strong></p>
<h2 id="Struct-pframe"><a href="#Struct-pframe" class="headerlink" title="Struct pframe"></a>Struct pframe</h2><p>There is a filed “vma_off” in struct “vmarea_t” and a field “pagenum” in struct pframe. Why do we need them?</p>
<p>The reason is that ** a mmobj can be shared by multiple vmareas, so the pages a vmarea need may not be equal to the pframe number a mmobj have**, so we need the vma_off as an offset.</p>
<p>For example, in the picture below, the file object is shared by 2 vmareas. Each vmarea needs 2 pages but the mmobj owns 4 pframes. With the help of vma_off, we can know that the vmarea A needs the first 2 pages(starting from vma_off = 0);the vmarea B needs the last 2 pages(starting from vma_off = 2).</p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix%20-%20Virtual%20Memory%20Overview/pframe_pagenum%20and%20vmarea_off.png">

<p>By the way, I was confused about pframe at first: since the physical page has a one-to-one mapping relationship with pframe, why do we need a pframe?</p>
<p>One reason is that looking up using pagetable is one direction: you can only use a virtual address to find the physical address. With the help of pframe, you can do the look up bi-directions, such as find out which process is using a particular page frame.</p>
<p>Another reason is that Weenix uses 3 linked list of pframes to manages physical pages. A page is always in one of three categories: free, allocated, pinned. These linked lists can simplify the work of page out daemon.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/15/Weenix/Weenix04 - Virtual Memeory Overview/" data-id="cjyxp3xe1001ljqm903ba069i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtual-Memory/">Virtual Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix03 - Debug-Virtual-File-System" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/02/Weenix/Weenix03 - Debug-Virtual-File-System/" class="article-date">
  <time datetime="2018-04-02T07:00:01.000Z" itemprop="datePublished">2018-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/02/Weenix/Weenix03 - Debug-Virtual-File-System/">Weenix03 - Debug Virtual File System</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua, Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>This article, which records some mistakes we made when implementing VFS for Weenix, is the follow-up for <a href="http://blog.taowang.cloud/2018/04/02/Weenix-Virtual-File-System-Overview/" target="_blank" rel="noopener">Weenix - Virtual File System Overview</a>. With the help of the detailed documentation, understanding the architecture of the Weenix VFS system and implementing the core functions are not that hard. However, debugging the kernel is torturing, because it is difficult to analyze the nodes, even with the help of GDB. </p>
<p>Below are 3 core functions for implementing VFS. You can read the comments of the source code of Weenix to get more information.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This takes a base 'dir', a 'name', its 'len', and a result vnode. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">vnode_t</span> *dir, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">vnode_t</span> **result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When successful this function returns data in the following "out"-arguments:</span></span><br><span class="line"><span class="comment"> *  o res_vnode: the vnode of the parent directory of "name"</span></span><br><span class="line"><span class="comment"> *  o name: the `basename' (the element of the pathname)</span></span><br><span class="line"><span class="comment"> *  o namelen: the length of the basename</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example: dir_namev("/s5fs/bin/ls", &amp;namelen, &amp;name, NULL,</span></span><br><span class="line"><span class="comment"> * &amp;res_vnode) would put 2 in namelen, "ls" in name, and a pointer to the</span></span><br><span class="line"><span class="comment"> * vnode corresponding to "/s5fs/bin" in res_vnode. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dir_namev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">size_t</span> *namelen, <span class="keyword">const</span> <span class="keyword">char</span> **name, <span class="keyword">vnode_t</span> *base, <span class="keyword">vnode_t</span> **res_vnode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function uses pathname to find the specified vnode if it exists */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag, <span class="keyword">vnode_t</span> **res_vnode, <span class="keyword">vnode_t</span> *base)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h1><p>Handling ref_count of file and vnode is the nightmare. Though it seems trivial to manage ref_count at the first glance, it is the root causes of the most bugs.</p>
<h2 id="1-Use-vput-too-early"><a href="#1-Use-vput-too-early" class="headerlink" title="1. Use vput() too early"></a>1. Use vput() too early</h2><p>The <strong>unlink</strong> system call is supposed to be implemented in this way: <em>Use dir_namev() to find the vnode of the directory containing the dir to be removed. Then call the containing dir’s unlink v_op</em>. When testing our implementation of <strong>unlink</strong> system call, the parent directory vnode returns <em>ENOTDIR(Not a directory)</em> unexpectedly. At first, we think that there are some bugs in our <strong>mknod</strong> implementation or in dir_namev() implementation, so we get the wrong vnode. However, we cannot find any related bugs when reviewing these code segments. We also made some similar mistakes in the implementation of other system calls.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Code segment of unlink system call - Wrong */</span></span><br><span class="line"><span class="keyword">int</span> dir_res = dir_namev(path, &amp;name_len, &amp;name, <span class="literal">NULL</span>, &amp;dir_node);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since we increase the vref count of parent_dir_vnode</span></span><br><span class="line"><span class="comment"> * We need to use vput to decrease it</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vput(dir_node);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A directory vnode has the lookup method while a file node does not */</span></span><br><span class="line"><span class="keyword">if</span>(dir_node-&gt;vn_ops-&gt;lookup == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Luckily we have GDB. After printing all the fields of the parent directory vnode, we found out that the vn_ops field points to NULL after executing vput(). This is because vput() function will delete most of a vnode’s fields when the ref_count s the vnode reaches zero, including the lookup function. </p>
<p>The solution is to delay executing vput(). </p>
<pre><code class="C"><span class="comment">/* Code segment of unlink system call - Correct */</span>
<span class="keyword">int</span> dir_res = dir_namev(path, &amp;name_len, &amp;name, <span class="literal">NULL</span>, &amp;dir_node);
...

<span class="comment">/* A directory vnode has the lookup method while a file node does not */</span>
<span class="keyword">if</span>(dir_node-&gt;vn_ops-&gt;lookup == <span class="literal">NULL</span>){
    vput(dir_node);
    ...
    <span class="keyword">return</span> -ENOTDIR;
}</code></pre>
<h2 id="2-Cannot-pass-vfstest-after-running-thrtest"><a href="#2-Cannot-pass-vfstest-after-running-thrtest" class="headerlink" title="2. Cannot pass vfstest after running thrtest"></a>2. Cannot pass vfstest after running thrtest</h2><p>We can pass vfstest successfully if we run it before running thrtest. However, if we run vfstest after running thrtest, we will get this error: </p>
<blockquote>
<p>panic in fs/ramfs/ramfs.c:255 ramfs_read_vnode(): assertion failed: inode &amp;&amp; inode-&gt;rf_ino == vn-&gt;vn_vno<br>Kernel Halting.</p>
</blockquote>
<p>Using gdb we can found out that the assertion is failed when executing path_equals(“/“, “/“), or more specifically, the assertion failed when we lookup “” in the root node. </p>
<p>We finally find the reason why we can’t lookup the empty name after thrtest. Because the rmdir function in ramfs doesn’t clean the entry-&gt;rd_ino, while it cleans the entry-&gt;rd_name.<br>For example,  before we run the thrtest, as for the root vnode, the entry(entry-&gt;rd_name, entry-&gt;rd_ino) can be {“.”, 0}, {“..”, 0}, {“dev”, 1}, {“vfstest-xxx”, 6}, {“”, 0}, {“”, 0}, then all the same. But when we run thrtest 2, the entry of the root vnode can be like {“.”, 0}, {“..”, 0}, {“dev”, 1}, {“dir000”, 27}, {“”, 0},…. After we called rmdir function, the entry just becomes {“.”, 0}, {“..”, 0}, {“dev”, 1}, {“”, 27}(we remove the directory), {“”, 0}, then we run the vfstest and lookup the empty name, we can just get the wrong entry-&gt;rd_ino and the corresponding file is already closed. So in </p>
<blockquote>
<p>KASSERT(inode &amp;&amp; inode-&gt;rf_ino == vn-&gt;vn_vno)<br>we will get the panic in<br>fs/ramfs/ramfs.c:255 ramfs_read_vnode(): assertion failed: inode &amp;&amp; inode-&gt;rf_ino == vn-&gt;vn_vno<br>Kernel Halting.<br>since inode is NULL.</p>
</blockquote>
<h2 id="3-File-Permission"><a href="#3-File-Permission" class="headerlink" title="3. File Permission"></a>3. File Permission</h2><p>Made some mistakes when handling permission of files. For example, write to a directory should not be allowed.</p>
<h2 id="4-Root-Vnode-is-not-handled-Correctly"><a href="#4-Root-Vnode-is-not-handled-Correctly" class="headerlink" title="4. Root Vnode is not handled Correctly"></a>4. Root Vnode is not handled Correctly</h2><p>When we create the idle process and init process, we should set the root_vnode as their current_working_direcotry and increase the ref_count of root_vnode. When cleaning up the idle and init process, we should also decrease the ref_count of root_vnode accordingly. </p>
<p>All processes except pageout daemon process have a current working directory, and you should handle this corner case elegantly. Otherwise, you will get page fault or your kernel cannot shutdown cleanly.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/02/Weenix/Weenix03 - Debug-Virtual-File-System/" data-id="cjyxp3xdw001jjqm9kpb62viw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix02 - Virtual-File-System-Overview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/02/Weenix/Weenix02 - Virtual-File-System-Overview/" class="article-date">
  <time datetime="2018-04-02T07:00:00.000Z" itemprop="datePublished">2018-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/02/Weenix/Weenix02 - Virtual-File-System-Overview/">Weenix02 - Virtual File System Overview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua, Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Before this post we have successfully implemented the thread related code for Weenix kernel. Now it is time to add support for the file system. Weenix has already provided us with the <strong>Actual File System</strong>(AFS) implementation, therefore, we only need to implement the code related to the <strong>Virtual File System(VFS)</strong>.</p>
<p>VFS is the abstraction layer beyond the AFS. VFS is like the interface while the AFS is the actual implementation. For example, VFS specifies that the AFS should implement read(), write() operations and how they should be implemented; different AFS can implement read() and write() in their own way. For Weenix, the AFS can be RAMFS, S5FS, etc.; for Linux, the AFS can be ext2, ext3, ext4, etc.; for Windows, the AFS can be FAT12, FAT32, FAT64, etc.. </p>
<p>Below are the 4 most important structs for VFS: struct <strong>proc</strong>, struct <strong>file</strong>, struct <strong>vnode</strong>, struct <strong>fs</strong>. For detailed information, please refer to the source code and the documentation of Weenix from Brown University.</p>
<img src="https://bytebucket.org/LarryTaoWang/pictureofblog/raw/f09ad8a1f1a76f16ab34c2dd0ac4702b4a324b00/Weenix/VFS%20structs.png">



<h1 id="Important-Structs"><a href="#Important-Structs" class="headerlink" title="Important Structs"></a>Important Structs</h1><p>To be short, proc struct stores a table of file descriptors, which can be used to find file struct. File struct stores the information of a file descriptor, which can be used to find a vnode struct. A vnode can be used to find an actual file system, struct fs. </p>
<h2 id="Struct-proc"><a href="#Struct-proc" class="headerlink" title="Struct proc"></a>Struct proc</h2><p>Every process struct* has its own file descriptor table, which is shared by its threads. When a child process is created, it will inherit this table(not the file!) from the parent process. </p>
<p>We can use p_files[NFILES] attribute to find the corresponding file struct of a file descriptor.</p>
<h2 id="Struct-file"><a href="#Struct-file" class="headerlink" title="Struct file"></a>Struct file</h2><p>Every entry in this table maps to a file struct, which stores the meta-data of the file descriptor and the associated vnode. One thing to notice is that the mode of a file descriptor is independent of the mode of a file. For example, if we open file A with only read permission, i.e.,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"A"</span>, O_RDONLY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Even though file “A” is created with both write and read permissions, you can only do read operation to this file, because the file descriptor is read-only.</p>
<p>Another important attribute is ref_count, which is the number of references to this struct. Different file descriptor may point to the same file struct, i.e., dup or creating a child process. When the ref_count is down to 0, the file struct will be cleaned up. </p>
<img src="https://bytebucket.org/LarryTaoWang/pictureofblog/raw/f09ad8a1f1a76f16ab34c2dd0ac4702b4a324b00/Weenix/File%20Descriptor%20After%20Fork.png">

<p>We can use node attribute to find the corresponding vnode struct of a file.</p>
<h2 id="Struct-vnode"><a href="#Struct-vnode" class="headerlink" title="Struct vnode"></a>Struct vnode</h2><p>One important attribute is the <strong>vnode_ops</strong>. VFS defines the operations an AFS should implement but different AFS can have different implementations. When we call the operation in VFS, the implementation of the corresponding AFS instance will be called. This feature is called <strong>polymofism</strong>. If you have worked with OOD languages such as C++ or Java, you should be quite familiar with this concept. C implements polymorphism with the function pointer. For further information, you can google “Objected-Oriented C”.</p>
<p><strong>vn_ref_count</strong> is the number of references to this vnode. But this can be much more complexed than ref_count in fs struct, because Weenix caches file into memories, and the memory pages will influence the ref_count of vnode. </p>
<p>Two important things to remember is that</p>
<ol>
<li>ref_count_of_vnode = ref_count_of_file + ref_count_from_memory_page</li>
<li>If ref_count_of_vnode = ref_count_from_memory_page, then no file is using this vnode, that is, only the cache is using the vnode. At this time we can safely free up this vnode.</li>
</ol>
<p>If you want more information, the Weenix documentation has an excellent introduction to this attribute as well as the corner case and optimization. </p>
<p>We can use <strong>fs</strong> attribute to find the corresponding vnode struct of a file.</p>
<p>One thing I want to complain is the design of the vnode struct and fs struct. These structs do not have a name attribute, which is supposed to correspond to the path name. The lacking path information makes debugging much harder. When using gdb to print the information of a node, since we don’t know the path name, we need to guess which pathname it belongs by analyzing the node is manually.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/04/02/Weenix/Weenix02 - Virtual-File-System-Overview/" data-id="cjyxp3xdu001gjqm9kmlgh35h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/File-System/">File System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weenix/Weenix01 - Process-and-Thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/Weenix/Weenix01 - Process-and-Thread/" class="article-date">
  <time datetime="2018-03-01T08:00:00.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Weenix/">Weenix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/Weenix/Weenix01 - Process-and-Thread/">Weenix01 - Process and Thread</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Weenix is the kernel assignment of my OS course. I and my teammates Xiaowei Cheng, Yanghua, Huang, Donghua Yin finishes all the assignment together, including designing, coding, reviewing, debugging. It is a great pleasure to work with and learn from them.</p>
</blockquote>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>The Weenix assignment is divided into 3 parts, and in the first part, we need to implement process, thread, and scheduling. In this assignment, we make some simplifications and assumes one process only has one thread.</p>
<p>A thread is the abstraction of CPU, it is also the basic unit for calculating. A process is the abstraction of the address space, that is, memory and a bunch of threads. </p>
<p>The entrance of Weenix is bootstrap() function in kmain.c, which creates the first process, that is, the idle process and then use context_make_active() to run the idle process. The idle process then creates init process and pageout process. Init process is the ancestor of all other processes. We can do the required logic in init process. For example, in kernel 1, we can create and run the faber test; in kernel 2 we can run kernel shell in init process; in kernel 3 we can run the user-space shell in init process.</p>
<blockquote>
<p>boostrap() -&gt;<br>idleproc_run() -&gt;<br>initproc_run()</p>
</blockquote>
<h1 id="Thread-and-Scheduling"><a href="#Thread-and-Scheduling" class="headerlink" title="Thread and Scheduling"></a>Thread and Scheduling</h1><p>The data structure of kthread is easy to understand. One thing to remember is that when a thread is first created, its kt_state should be KT_NO_STATE; after another thread makes it runnable, its kt_state becomes KT_RUN and enqueue into the run queue. </p>
<p>But the code of scheduling is tricky. Let’s look at them one by one.</p>
<h2 id="Sched-switch"><a href="#Sched-switch" class="headerlink" title="Sched_switch"></a>Sched_switch</h2><p>The textbook offers the pseudo code for this function and “context_switch()” is extremely important. <strong>When a thread gets the CPU again, it will execute right after the context_switch() function as if it never gives up CPU.</strong></p>
<p>The picture is as follow:<br><img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix01%20/Context_Switch.png"></p>
<h2 id="Cancellable-sleep-on"><a href="#Cancellable-sleep-on" class="headerlink" title="Cancellable_sleep_on()"></a>Cancellable_sleep_on()</h2><p>This function is also hard to understand. The idea of <strong>Cancellable</strong> in weenix kernel is similar to cancellation in pthreads, that is, <strong>cancellable_sleep_on() is sched_sleep_on plus checking cancellation point.</strong></p>
<p>Since a kernel thread cannot die in a cancellation point, the return value of this function indicates whether this thread should go canceled or not. Afterward, the function that calls Cancellable_sleep_on() is responsible for how to deal with the canceled thread.</p>
<p>Therefore, the pseudo code is like that:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sched_cancellable_sleep_on(<span class="keyword">ktqueue_t</span> *q)</span><br><span class="line">&#123;       </span><br><span class="line">        <span class="keyword">if</span> the thread is canceled &#123;</span><br><span class="line">                <span class="keyword">return</span> immediately;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> similar logic in sched_sleep_on;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> the thread is canceled &#123;</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h1><p>You can refer to the textbook for details of the pseudocode of mutex, which is a little tricky. Let’s see an example of how this code segment works, assuming that there are only 2 threads competing for the mutex.</p>
<img src="https://bitbucket.org/LarryTaoWang/pictureofblog/raw/master/Weenix/Weenix01%20/Mutex.png">


<h1 id="Proc"><a href="#Proc" class="headerlink" title="Proc"></a>Proc</h1><p>It is difficult to divide the responsibility of exit() and do_waitpid(). Generally, <strong>when executing exit(), the process should clean as many resources as possible and wake up its parent if it is waiting; afterward, the parent will finish destroying the process within do_waitpid().</strong></p>
<h2 id="Do-waitpid"><a href="#Do-waitpid" class="headerlink" title="Do_waitpid()"></a>Do_waitpid()</h2><p>When a process executes do_waitpid(), its thread should be blocked on its own kt_wchan. </p>
<p>If the parent is waiting for a specific child thread, that is, do_waitpid(PID != -1), the implementation is simple; the parent process finds the child process with the given pid and then cleans up the child process.</p>
<p>If the parent is waiting for any child thread, that is, do_waitpid(PID == -1), things will be a little different. Now the parent process should wait for any pid to exit and then dispose of it. <strong>If the parent is wakened up and there are multiple dead child processes, do_wait for the first dead child process.</strong> </p>
<h1 id="Pitfalls"><a href="#Pitfalls" class="headerlink" title="Pitfalls"></a>Pitfalls</h1><h2 id="Fail-to-execute-break-in-list-iterate-macros"><a href="#Fail-to-execute-break-in-list-iterate-macros" class="headerlink" title="Fail to execute break in list iterate macros"></a>Fail to execute break in list iterate macros</h2><p>Several macros have the similar format. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_iterate_begin(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; list_iterate_end();</span><br></pre></td></tr></table></figure>

<p>In these macros, if you use break, the break operation will never succeed. Use <strong>goto</strong> instead.</p>
<h2 id="Pageout-Process"><a href="#Pageout-Process" class="headerlink" title="Pageout Process"></a>Pageout Process</h2><p>The idle process has 2 children: pageout process and init process. Sometimes you need to handle the corner case of the pageout process.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p>[1] <em>Operating Systems in Depth</em>, Thomas W. Doeppner, Brown University<br>[2] <a href="https://cs.brown.edu/courses/cs167/content/weenix-doc.pdf" target="_blank" rel="noopener">Weenix Documentation
</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog-pika.github.io/2018/03/01/Weenix/Weenix01 - Process-and-Thread/" data-id="cjyxp3xdt001fjqm94h0af863" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Process/">Process</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread/">Thread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Coding-Notes/">Coding Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Weenix/">Weenix</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Distributed-System/">Distributed System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/File-System/">File System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fork/">Fork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K-Means/">K-Means</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Operating-System/">Operating System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pattern-Matching/">Pattern Matching</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Process/">Process</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Replication/">Replication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark-SQL/">Spark SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread/">Thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtual-Memory/">Virtual Memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Weenix/">Weenix</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 20px;">C</a> <a href="/tags/Distributed-System/" style="font-size: 10px;">Distributed System</a> <a href="/tags/File-System/" style="font-size: 13.33px;">File System</a> <a href="/tags/Fork/" style="font-size: 10px;">Fork</a> <a href="/tags/K-Means/" style="font-size: 10px;">K-Means</a> <a href="/tags/Operating-System/" style="font-size: 20px;">Operating System</a> <a href="/tags/Pattern-Matching/" style="font-size: 10px;">Pattern Matching</a> <a href="/tags/Process/" style="font-size: 10px;">Process</a> <a href="/tags/Replication/" style="font-size: 10px;">Replication</a> <a href="/tags/Scala/" style="font-size: 16.67px;">Scala</a> <a href="/tags/Spark/" style="font-size: 13.33px;">Spark</a> <a href="/tags/Spark-SQL/" style="font-size: 10px;">Spark SQL</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/Virtual-Memory/" style="font-size: 10px;">Virtual Memory</a> <a href="/tags/Weenix/" style="font-size: 20px;">Weenix</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/01/Replicattion-101/">Replication 101</a>
          </li>
        
          <li>
            <a href="/2018/04/20/Weenix/Weenix09 - Summary/">Weenix09 - Summary</a>
          </li>
        
          <li>
            <a href="/2018/04/20/Weenix/Weenix08 - Fork/">Weenix08 - Fork</a>
          </li>
        
          <li>
            <a href="/2018/04/20/Weenix/Weenix07 - Shadow Object/">Weenix07 - Shadow Object</a>
          </li>
        
          <li>
            <a href="/2018/04/15/Weenix/Weenix06 - Debug anon_put()/">Weenix06 - Debug anon_put()</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Developer Pikachu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>